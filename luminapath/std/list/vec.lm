use std:ptr 
use std:list [Listable]
use std:list:slice [Slice]
use std:math [Compare [>=]]
use std:io [crash]
use std:string [<>]

// An immutable heap-allocated array
pub type Vec a {
  ptr *a
  len uint
}

pub fn capacity len as uint -> Vec a =
  let ptr = std:prelude:alloc ((Type(a):size * len) as int)
   in { ptr = ptr as *a, len }

pub fn empty as Vec a = { Vec a | ptr = ptr:null, len = 0 }

pub fn singleton v as a -> Vec a = 
  { ptr = ptr:box v, len = 1 }

pub fn to_slice {ptr, len} as Vec a -> Slice a =
  { Slice a | ptr, len, source = ptr }

pub fn get i vec as uint, Vec a -> Maybe a =
  if i >= vec.len
    then Nothing
    else Just (unsafe_get i vec)

pub fn unsafe_get i {ptr, len} as uint, Vec a -> a =
  ptr:offsetu ptr (Type(a):size * i) . ptr:deref

pub fn unsafe_set i v {ptr, len} as uint, a, Vec a -> () =
   let at = ptr:offsetu ptr (Type(a):size * i) in
    ptr:write at v

pub fn from_range (start, end) f as (uint, uint), fn(uint -> a) -> Vec a =
  if start > end then
    crash ("error: from_range end larger than start " <> end <> " > " <> start)
  else
  let count = (end - start) in 
  let vec = capacity count in
    do list:itimes #(\i -> unsafe_set i (f (i + start)) vec) count
    then vec

fn bytes_from_null_terminated ptr as *u8 -> Vec u8 =
  findZero 0
 where
  fn findZero i as uint -> Vec u8 = 
    if ptr:deref (ptr:offsetu ptr i) == 0
      then { ptr, len = i }
      else findZero (i + 1)

pub fn unsafe_take n {ptr, len} as uint, Vec a -> Vec a =
  { ptr, len = n }

pub fn map f vec as fn(a -> b), Vec a -> Vec b = 
  from_range
    (0, vec.len)
    #(\i -> unsafe_get i vec . f)

pub fn clone vec as Vec a -> Vec a =
  from_range
    (0, vec.len)
    #(\i -> unsafe_get i vec)

when a can ToString
impl ToString for Vec a
  fn show vec as self -> string =
    show (vec . to_slice)
