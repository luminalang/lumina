//! An attempt at parsing generalised token-tree-like structures which can then be converted into
//! expressions, types and patterns.

mod lexer;
pub use lexer::{Lexer, Token};
mod path;
use lumina_util::{Error, Span, Spanned, Tr};
pub use path::AnnotatedPath;

type Entities<'s> = Vec<Tr<Entity<'s>>>;

#[derive(Clone, Debug)]
pub enum Entity<'s> {
    Commented(&'s str, bool, Box<Tr<Self>>),
    // a b -> c
    //     ^^
    Delim(&'s str, Box<[Tr<Self>; 2]>),
    Operator(AnnotatedPath<'s>, Box<[Tr<Self>; 2]>),
    Literal(Literal<'s>),
    Group(Vec<Tr<Self>>),
    Identifier(AnnotatedPath<'s>),
    Keyword(&'s str, Box<Tr<Self>>),
    /// Entities which are indented under this where-block
    Where(Entities<'s>),
    /// Entities which are indented under this impl-block
    Impl(Entities<'s>),
    /// Entities which are indented under this when-block
    When(Entities<'s>),
}

#[derive(Clone, Debug)]
pub enum Literal<'s> {
    Int(bool, u128),
    Float(f64),
    DoubleQuote(&'s str),
    SingleQuote(&'s str),
}

#[derive(Clone)]
pub struct Parser<'a> {
    lexer: Lexer<'a>,
    errors: Vec<Error>,
}

enum Constr<'s> {
    Singleton(Tr<Entity<'s>>),
    Delim {
        middle: Tr<&'s str>,
        rhs: Tr<Entity<'s>>,
    },
}

impl<'s> Parser<'s> {
    fn take(&self, span: Span) -> &'s str {
        span.get_str(self.lexer.source())
    }

    fn int(&self, span: Span) -> Entity<'s> {
        let raw = self.take(span);
        let parse = |span| self.take(span).parse::<u128>().unwrap();
        let (sign, n) = if raw.as_bytes()[0] == b'-' {
            (true, parse(span.move_indice(1)))
        } else {
            (false, parse(span))
        };
        Entity::Literal(Literal::Int(sign, n))
    }

    fn entity(&mut self) -> Tr<Entity<'s>> {
        let (token, span) = self.lexer.peek();
        match token {
            Token::NewLines => {
                self.lexer.next();
                return self.entity();
            }
            Token::StringLiteral => {
                self.lexer.next();
                let data = self.take(span.move_indice(1).shortened(1));
                Entity::Literal(Literal::DoubleQuote(data))
            }
            Token::CharLiteral => {
                self.lexer.next();
                let data = self.take(span.move_indice(1).shortened(1));
                Entity::Literal(Literal::SingleQuote(data))
            }
            Token::Int => {
                self.lexer.next();
                self.int(span)
            }
            Token::Float => {
                self.lexer.next();
                let n = self.take(span).parse().unwrap();
                Entity::Literal(Literal::Float(n))
            }
            Token::LineDocComment | Token::LineComment => {
                self.lexer.next();
                let comment = self.take(span);
                let inner = self.entity();
                Entity::Commented(comment, token == Token::LineDocComment, Box::new(inner))
            }
            Token::If => {
                self.lexer.next();
                let inner = self.entity();
                Entity::Keyword("if", Box::new(inner))
            }
            Token::Can => {
                todo!("we probably want to return something special that can wrap this?");
            }
            Token::As => todo!(),
            Token::Where => todo!(),
            Token::When => todo!(),
            Token::Match => todo!(),
            Token::Then => todo!(),
            Token::Else => todo!(),
            Token::OpenParen => todo!(),
            Token::CloseParen => todo!(),
            Token::OpenCurly => todo!(),
            Token::OpenList => todo!(),
            Token::CloseList => todo!(),
            Token::SemiColon => todo!(),
            Token::CloseCurly => todo!(),
            Token::Comma => todo!(),
            Token::Arrow => todo!(),
            Token::Let => todo!(),
            Token::In => todo!(),
            Token::Do => todo!(),
            Token::Backslash => todo!(),
            Token::Square => todo!(),
            Token::SquareExt => todo!(),
            Token::Fn => todo!(),
            Token::FnPtr => todo!(),
            Token::Alias => todo!(),
            Token::Type => todo!(),
            Token::Trait => todo!(),
            Token::Use => todo!(),
            Token::Impl => todo!(),
            Token::Val => todo!(),
            Token::OpenAttribute => todo!(),
            Token::OpenModuleAttribute => todo!(),
            Token::Symbol => todo!(),
            Token::Path => todo!(),
            Token::AnnotatedPath => todo!(),
            Token::Error => todo!(),
            Token::EOF => todo!(),
        }
        .tr(span)
    }
}
